## Java 内存模型

Java 内存模型的主要目的是定义程序中各种变量的访问规则。



### 主内存（Main Memory）与工作内存（Working Memory）

Java 内存模型规定了所有的变量都存储在主内存中。每条线程都有自己的工作内存，保存了该线程使用的变量和主内存副本，线程对变量的所有读写操作都必须在工作内存中进行。不同线程之间也无法直接访问对方的工作内存，线程间的变量传递必须经过主内存。

**主内存、工作内存与 Java 内存区域中的堆、栈、方法区并不是同一个层次的对内存的划分。**



### 内存见的交互操作

Java 内存模型定义了 8 中操作来完成内存交互：

* **lock（锁定）**：作用于主内存的变量，把一个变量表示为一个线程独占的状态。
* **unlock（解锁）**：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定。
* **read（读取）**：作用于主内存的变量，把一个变量的值从主内存传输到工作内存中，一边随后的 load 操作使用。
* **load（载入）**：作用于工作内存的变量，把一个 read 操作从主内存中读取到的变量值放入工作内存的变量副本中。
* **use（使用）**：作用于工作内存中的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将执行这个操作。
* **assign（赋值）**：作用于工作内存的变量，把从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将执行这个操作。
* **store（存储）**：作用于工作内存的变量，把工作内存中一个变量的值传递到主内存中，以便之后的 write 操作使用。
* **write（写入）**：作用于主内存的变量，把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

Java 内存模型还规定了在执行上述 8 中基本操作时必须满足以下规则：

* **不允许 read 和 load、store 和 write 操作之一单独出现。**即不允许一个变量从主内存中读取了但工作内存不接受或者工作内存发起回写但主内存不接受的情况。
* **不允许一个线程丢弃它最近的 assign 操作。**即变量在工作内存中改变了之后必须要同步回主内存中。
* **不允许一个线程在没有执行 assign 操作时把数据同步回主内存。**
* **一个新的变量只能在主内存中诞生。**即不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。
* **一个变量在同一时刻只允许一个线程对其进行 lock 操作，但 lock 操作可以被同一个线程重复执行多次，只有执行相同次数的 unlock 操作之后变量才会被解锁。**
* **如果对一个变量执行了 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。**
* **如果一个变量没有被执行过 lock 操作，就不允许对它进行 unlock 操作，也不允许对其一个被他线程锁定的变量执行 unlock 操作。**
* **对一个变量执行 unlock 操作之前，必须先把它同步回主内存中，即执行 store 和 write 操作。**



### 原子性、可见性和有序性

#### 1、原子性（Atomicity）

由 Java 内存模型直接保证的原子性变量操作包括：read、load、assign、use、store 和 write。大致可以认为对基本数据类型的访问、读写都具备原子性。

#### 2、可见性（Visibility）

指当一个线程修改了某个变量的值时，其他线程能够立即得知这个修改。Java 内存模型通过在变量修改后同步回主内存，在变量读取前从主内存刷新变量值来实现可见性。`volatile` 关键字就是如此，此外 `synchronized` 和 `final` 两个关键字也能保证可见性。`final` 的可见性是指：被 `final` 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 `this` 的引用传递出去，那么其他线程中就能看见 `final` 字段的值。

#### 3、有序性（Ordering）

Java 程序中天然的有序性：**在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的**。Java 语言提供了 `volatile` 和 `synchronized` 两个关键字来保证线程间操作的有序性。`volatile` 包含了禁止指令重排序的语义，`synchoronized` 则是由“一个变量在同一个时刻只允许一个线程对其进行 lock 操作”保证的。



### 先行发生原则（Happens-Before）

它是判断数据是否存在竞争，线程是否安全的非常有用的手段。Java 内存模型下一些天然的先行发生关系：

* **程序次序规则（Program Order Rule）**：在一个线程内，按照控制流的顺序，书写在前面的操作先行发生于书写在后面的操作。
* **管程锁定规则（Monitor Lock Rule）**：一个 unlock 操作先行发生于*后面*对*同一个锁*的 lock 操作。
* **volatile 变量规则（Volatile Variable Rule）**：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。
* **线程启动规则（Thread Start Rule）**：Thread 对象的 start() 方法先行发生于此线程的每一个动作。
* **线程终止规则（Thread Termination Rule）**：线程中的所有操作都先行发生于对此线程的终止检测。
* **线程中断规则（Thread Interruption Rule）**：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。
* **对象终结规则（Finalizer Rule）**：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。
* **传递性（Transitivity）**：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。

Java 语言无须任何同步手段保障就能成立的先行发生规则**有且只有**上面这些。



### volatile 关键字

当一个变量被定义成 volatile 后，它具备两项特性：**1、保证此变量对所有线程的可见性。2、禁止指令重排序优化。**由于 volatile 只能保证可见性，在不符合以下两条规则的运算场景中，仍然需要通过加锁来保证原子性：

* 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
* 变量不需要于其他的状态变量共同参与不变约束。



### 线程安全

当一个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。 -- 《Java 并发编程实战》

#### Java 语言中的线程安全

Java 语言中各种操作共享的数据分为五类：不可变，绝对线程安全，相对线程安全，线程兼容和线程对立。

##### 1、不可变

在 JDK5 以后，不可变（Immutable）的对象一定是线程安全的。在 Java 语言中，如果多线程共享的数据是一个基本数据类型，只要在定义时使用 `final` 关键字修饰就可以保证它是不可变。如果共享数据是一个对象，就需要对象自行保证其行为不会对其状态产生任何影响才行，比如 `java.lang.String` 类的对象实例。

##### 2、绝对线程安全

一个类要达到绝对线程安全需要付出的代价非常高昂。Java API 中标注的线程安全的类，大多都不是绝对线程安全的。

##### 3、相对线程安全

就是通常意义上讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，但是对于一些特定顺序的连续调用，调用端仍然需要使用额外的同步手段来保证调用的正确性。在 Java 语言中声称线程安全的类大部分属于这种类型。

##### 4、线程兼容

指对象本身并不是线程安全的，但通过在调用端正确的使用同步手段来保证对象在并发环境中可以安全的使用。

##### 5、线程对立

指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。如 `Thread` 类的 `suspend()` 和 `resume()`，如果两个线程同时持有一个线程对象，一个尝试调用 `suspend()` 方法，一个尝试调用 `resume()` 方法，在并发情况下，无论调用时是否进行了同步，目标线程都有可能出现死锁。

#### 线程安全的实现方法

##### 1、互斥同步（Mutual Exclusion & Synchronization）

指在多个线程同时访问共享数据时，保证共享数据在同一时刻只被一个（或者是一些，当使用信号量的时候）使用。也被成为阻塞同步（Blocking Synchronization）。互斥是因，同步是果；互斥是方法，同步是目的。在 Java 中最基本的互斥同步手段就是 `synchronized` 关键字，这是一种块结构的同步语法。如果 Java 与代码中的 `synchronized` 明确指定了对象参数，那就以这个对象作为锁，否则根据 `synchronized` 修饰的方法类型来决定是取代码所在的对象实例还是取类型对应的 Class 对象作为锁。`synchronized` 的锁是非公平的。

* 被 `synchronized` 修饰的同步块对同一个线程时可重入的。
* 被 `synchronized` 修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。

##### 2、非阻塞同步

基于冲突检测的乐观并发策略，即不管风险，先进行操作，如果没有其他线程争用共享数据，那么操作就成功了，如果共享数据被争用，产生了冲突，那就进行其他的补偿措施，最常用的补偿措施就是不断的重试，直到成功。

##### 3、无同步方案

同步和线程安全没有必然的联系，同步只是保障存在共享数据争用时正确性的手段。

* 可重入代码（Reentrant Code）：又称纯代码（Pure Code），指可以在代码执行的任何时刻中断它，去执行另一段代码（包括地柜调用自身），在控制权返回后，原理的程序不会出现任何问题，也不会对结果有影响。
* 线程本地存储（Thread Local Storage）：如果一段代码中所需要的共享数据必须与其他代码共享，那就看看这些共享数据的代码能否保证在同一个线程中执行，如果能保证，就可以把共享数据的可见范围限制在同一个线程之内。

