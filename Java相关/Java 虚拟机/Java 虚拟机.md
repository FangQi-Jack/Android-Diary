# **Java 虚拟机**
## Java 虚拟机的执行流程
Java 虚拟机的执行流程分为两部分：编译时环境和运行时环境。当一个 Java 文件被 Java 编译器编译成 Class 文件后，才能由 Java 虚拟机进行处理。Java 虚拟机与 Java 语言没有必然的联系，它只与特定的二进制文件：Class 文件有关。
## Java 虚拟机的结构
![Java 虚拟机结构](https://github.com/FangQi-Jack/Android-/blob/main/Java%E7%9B%B8%E5%85%B3/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BB%93%E6%9E%84.png)

## 类的生命周期
1、**加载**：查找并加载 Class 文件

2、**链接**：包括**验证**、**准备**和**解析**

* **验证**：确保被导入类型的正确性
* **准备**：为类的静态字段分配字段，并用默认值初始化这些字段
* **解析**：虚拟机将常量池内的符号引用替换为直接引用

3、**初始化**：将类变量初始化为正确的初始值

4、**使用**

5、**卸载**

加载阶段主要做了 3 件事情：
* **根据特定名称查找类或接口类型的二进制字节流**
* **将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构**
* **在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口**

## 类加载子系统
**1、Bootstrap ClassLoader（引导类加载器）**
用 C/C++ 代码实现的加载器，用于加载指定的 JDK 的核心类库。用来加载以下目录：
* $JAVA_HOME/jre/lib
* -Xbootclasspath 参数指定的目录
Java 虚拟机的启动就是通过引导类加载器创建一个初始类来完成的。该加载器不能被 Java 代码访问。

**2、Extensions ClassLoader（拓展类加载器）**
用于加载 Java 的拓展类，提供除了系统类之外的额外功能。用来加载以下目录：
* $JAVA_HOME/jre/lib/ext
* 系统属性 java.ext.dir 所指定的目录

**3、Application ClassLoader（应用程序类加载器）**
也称作 System ClassLoader，可以通过 ClassLoader 的 getSystemClassLoader 方法获取到。用来加载以下目录：
* 当前应用程序 Classpath 目录
* 系统属性 java.class.path 指定的目录

## 运行时数据区
1、**程序计数器**
也叫作 PC 寄存器，是一块较小的内存空间。字节码解释器工作时通过改变程序计数器来选取下一条需要执行的字节码指令。为了在线程切换后能恢复到正确的执行位置，每一个线程都有一个独立的程序计数器，因此程序计数器是线程私有的。程序计数器是 Java 虚拟机规范中唯一没有规定任何 OutOfMemoryError 的数据区域。

2、**Java 虚拟机栈**
每个线程都有一个私有的 Java 虚拟机栈，他的生命周期与线程相同，与线程同时创建。用来存储线程中 java 方法调用的状态，包括局部变量、参数、返回值以及运算的中间结果等。一个 Java 虚拟机栈包含多个栈帧，一个栈帧用来存储局部变量表、操作数栈、动态链接、方法出口等信息。Java 虚拟机规范中定义了两种异常情况：
* 如果线程请求分配的栈容量超过 Java 虚拟机所允许的最大容量，会抛出 StackOverflowError。
* 如果 Java 虚拟机栈可以动态扩展，但扩展时无法申请到足够的内存，或者在创建新线程时没有足够的内存去创建对应的 java 虚拟机栈，则会抛出 OutOfMemoryError。

3、**本地方法栈**
Java 虚拟机的实现可能要用到 C Stacks 来支持 Native 语言，C Stacks 就是本地方法栈。也会抛出 StackOverflowError 和 OutOfMemoryError。

4、**Java 堆**
所有线程共享的运行时内存区域，用来存放对象实例。存储的对象被垃圾收集器管理，这些被管理的对象无法显示的销毁。Java 堆的内存在物理上不需要连续，在逻辑上连续即可。Java 虚拟机规范中定义了一种异常情况：

* 如果在堆中没有足够的内存来完成实例分配，并且堆也无法进行扩展时，会抛出 OutOfMemoryError。

5、**方法区**
所有线程共享的运行时内存区域，用来存储已经被 Java 虚拟机加载的类的结构信息，包括运行时常量池、字段和方法信息、静态变量的数据。它是 Java 堆的逻辑组成部分。方法区中可以选择不实现垃圾收集。Java 虚拟机规范中定义了一种异常情况：

* 如果方法区的内存空间不满足内存分配需求时，会抛出 OutOfMemoryError。

6、**运行时常量池**
方法区的一部分。用来存放编译时期生成的字面量和符号引用，这些内容会在类加载后存放在方法区的运行时常量池中。可以理解为类或接口的常量池的运行时表现形式。Java 虚拟机规范中定义了一种异常情况：

* 当创建类或接口时，如果构造运行时常量池所需的内存超过了方法区所能提供的最大值，会抛出 OutOfMemoryError。

## 对象的创建
**1、判断对象对应的类是否加载、链接和初始化**

**2、为对象分配内存**
有两种方式：
*  ***指针碰撞***：如果 Java 堆的内存是规整的，即所有用过的内存在一边，空闲的内存在另一边。分配内存时将位于中间的指针指示器向空闲区移动一段与对象大小相等的距离，完成内存分配工作。
*  ***空闲列表***：如果 Java 堆的内存不是规整的，则需要由虚拟机维护一个列表来记录哪些内存时可用的，分配内存时从列表中查询到足够大的内存分配给对象，而后更新列表记录。

**3、处理并发安全问题**
有两种方式：

* 堆分配内存空间的动作进行同步处理，比如在虚拟机采用 CAS 算法并配上失败重试的方式保证更新操作的原子性
*  每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），线程需要分配内存时，就在对应的 TLAB 上进行分配，当 TLAB 用完并且被分配到了新的 TLAB 时，这时候才需要同步锁定。

**4、初始化分配到的内存空间**

**5、设置对象的对象头**

**6、执行 init 方法进行初始化**

## 对象的堆内存布局

HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为 3 个部分：

1、**对象头（Header）**。包括两类信息：

* 用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。官方称它为 Mark Word，有着动态的数据结构，以便在极小的空间内存储尽量多的信息。
* 类型指针，即对象指向它的类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是那一个类的实例。并不是所有虚拟机实现都必须在对象数据上保留类型指针，即查找对象的元数据信息并不一定要经过对象本身。

2、**实例数据（Instance Data）**。是对象真正存储的有效信息，即在代码中所定义的各种类型的字段内容。

* **对齐填充（Padding）**。不是必然存在的，没有特别含义，仅仅起占位符的作用。

## 垃圾标记算法
### 引用计数算法
基本思想是每个对象都有一个引用计数器，在对象被引用时加 1，引用失效时减 1。无法解决对象之间循环引用的问题。
### 根搜索算法
基本思想是选定一些对象作为 GC Roots，并组成根对象集合，然后以这些 GC Roots 的对象作为起点，向下搜索，如果目标对象到 GC Roots 是连接着的，则称目标对象是可达的，否则就说明目标对象不可达，是可以被回收的。
在 Java 中可以作为 GC Roots 的对象主要有：
* Java 栈中引用的对象
* 本地方法栈中 JNI 引用的对象
* 方法区中运行时常量池引用的对象
* 方法区中静态属性引用的对象
* 运行中的线程
* 由引导类加载器加载的对象
* GC 控制的对象

## Java 对象在虚拟机中的生命周期
**1、创建阶段（Created）**
> (1)为对象分配存储空间
> 
> (2)构造对象
> 
> (3)从父类到子类堆 static 成员进行初始化
> 
> (4)递归调用父类的构造方法
> 
> (5)调用子类的构造方法

**2、应用阶段（In Use）**
对象被创建，并分配给变量赋值时，就切换到了应用阶段。

**3、不可见阶段（Invisible）**
在程序中找不到对象的任何强引用。在该阶段，对象仍可能被特殊的强引用 GC Roots 持有着，比如被本地方法栈中 JNI 引用或被运行中的线程引用。

**4、不可达阶段（Unreachable）**
在程序中找不到对象的任何强引用，并且垃圾收集器发现对象不可达。

**5、收集阶段（Collected）**
垃圾收集器发现对象不可达，并且已经准备要对该对象的内存空间重新进行分配，如果该对象重写了 finalize 方法，此时则会调用该方法。

**6、终结阶段（Finalized）**
执行完对象的 finalize 方法后仍处于不可达阶段或者对象没有重写 finalize 方法，则会进入终结阶段，并等待垃圾收集器回收该对象的内存空间。

**7、对象空间重新分配阶段（Deallocated）**

## 垃圾收集算法
### 标记-清除算法
* 标记阶段：标记出可以回收的对象
* 清除阶段：回收被标记的对象所占用的内存空间
缺点：1、效率不高。2、容易产生大量不连续的内存碎片。
### 复制算法
把内存空间划分为两个相等的区域，每次只是用其中一个区域，在垃圾收集时，遍历当前使用的区域，把存活的对象复制到另一个区域中，最后将当前使用的区域的可回收对象进行回收。广泛应用于新生代中。
缺点：1、使用内存为原来的一半。2、如果存活对象过多，复制效率会变低。
### 标记-压缩算法
在标记可回收的对象后将所有存活对象压缩到内存的一端，使它们紧凑的排列在一起，然后对边界以外的内存进行回收。广泛应用于老年代中。
### 分代收集算法
结合不同的算法处理不同的空间。Java 堆基于分代的概念分为：新生代和老年代。新生代在细分为 Eden 空间、From Survivor 空间和 To Survivor 空间。
* Minor Collection：新生代垃圾收集
* Full Collection：老年代垃圾收集。频率低，耗时长。通常会伴随至少一次 Minor Collection。
当执行一次 Minor Collection 时，Eden 空间的存活对象会被复制到 To Survivor 空间，并且之前经历过一次 Minor Collection 并在 From Survivor 空间存活的仍年轻的对象也会复制到 To Survivor 空间。有两种情况 Eden 空间和 From Survivor 空间存活的对象不会复制到 To Survivor 空间，而是晋升到老年代：1、存活的对象的分代年龄超过 -XX:MaxTenuringThreshold(用于控制对象经历多少次 Minor Collection 才晋升到老年代)所指定的阈值。2、To Survivor 空间容量达到阈值。
执行 Minor Collection，Eden 空间和 From Survivor 空间都会被清空，接下来将 From Survivor 和 To Survivor 互换位置。

